#! /usr/bin/env python3

import argparse
import yaml
import re
import warnings

from operator import attrgetter
from datetime import datetime
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, contextfilter
from shutil import copytree, rmtree
from os import symlink
from anytree import Node, RenderTree, Resolver, PreOrderIter, LevelOrderIter, LevelOrderGroupIter
from anytree.search import find_by_attr as findNode
from anytree.resolver import ResolverError, ChildResolverError
from anytree.exporter import DictExporter
from anytree.render import AsciiStyle


from pprint import PrettyPrinter
_pp = PrettyPrinter(indent=1).pprint

# Global helper to store parsed command line arguments
_args = None

# Global helper to store the Jinja environment
_env = None

# Global helper to store links
_globalLinks = None

#---------------------
# Parse Arguments
#---------------------

def parse_arguments():
    global _args
    
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-y',
        '--yaml-cfg',
        default = 'wiki.yml',
        help = 'Wiki configuration file, in lieu of passed options.'
    )
    
    parser.add_argument(
        '-o',
        '--output',
        default = './docs',
        help = 'Output root directory. Defaults to "./docs"'
    )
    
    parser.add_argument(
        '-t',
        '--templates',
        default = './templates',
        help = 'Directory path to get custom templates from. Defaults to "./templates"'
    )

    parser.add_argument(
        '-l',
        '--lib',
        default = './lib',
        help = 'Root library directory. Defaults to "./lib"'
    )
    
    parser.add_argument(
        '--stylesheets',
        help = 'Directory relative to --lib to get custom stylesheets. Note: stylesheets must be added to mkdocs.yml.j2'
    )
    
    parser.add_argument(
        '--js',
        help = 'Directory relative to --lib to get custom javascript. Note: js must be added to mkdocs.yml.j2'
    )
    
    parser.add_argument(
        '--img',
        help = 'Directory relative to --lib to get custom images.'
    )
    
    parser.add_argument(
        '-v',
        '--verbose',
        default = 0,
        action = 'count',
        help = 'Print debug information.'
    )
    
    args = parser.parse_args()
    
    wikiCfg = Path(args.yaml_cfg)
    if wikiCfg.exists():
        with open(wikiCfg, 'r') as wikiCfg_file:
            cfg_data = yaml.load(wikiCfg_file, Loader=yaml.FullLoader)
    
        for key, value in cfg_data.items():
            cmdVal = getattr(args, key, None)
            if cmdVal is None:
                setattr(args, key, value)
            else:
                msg = f'{key} from WikiCfg overridden by command line: {cmdVal}'
                warnings.warn(msg)

    _args = args

#--------------------------
# Helper Functions
#--------------------------

def ageDecode(event):
    map_ = {'KAL' : 1, 'IDE' : 20, 'NON' : 28, 'X' : 2}
    ageStr = event['Date']
    ageList = ageStr.split(' ')
    ageList.extend(['0KAL','0KAL','0KAL'])
    ageList[0] = int(re.sub(r'[^- 0-9]', '', ageList[0]))
    ageList[1] = int(re.sub(r'[^ 0-9]', '', ageList[1]))
    try:
        day = int(re.sub(r'([0-9]*).*', r'\1', ageList[2]))
    except ValueError:
        day = 1
    mark = re.sub(r'[0-9]*(KAL|IDE|NON|X)', r'\1', ageList[2])
    ageList[2] = (32 - map_[mark] - (day - 2)) % 31
    return (ageList[0], ageList[1], ageList[2])


def resolveTreeNode(tree, pathStr):
    resolver = Resolver('name')
    try:
        node = resolver.get(tree, pathStr)
    except (ResolverError, ChildResolverError):
        parent = resolveTreeNode(tree, pathStr.rsplit('/',1)[0])
        node = Node(pathStr.split('/')[-1], parent=parent)
        
    return node


#--------------------------
# Custom Jinja Filters
#--------------------------

@contextfilter
def autoLink(ctx, rawText):
    if 'no_autolink' in ctx.resolve('control'):
        return rawText
    myTitle = ctx.resolve('title')
    for linkTarget in _globalLinks:
        searchText = linkTarget['text']
        linkText = linkTarget['link']
        if (linkText != myTitle):
            searchPattern = r'\b' + f"({searchText}('?s?)?)" + r'\b' + r'(?![^[]*])'
            replaceText = r'[\1]' + f'[{linkText}]'
            rawText = re.sub(searchPattern, replaceText, rawText, count=1)
    return rawText


@contextfilter
def relativeLink(ctx, rawText):
    myTitle = ctx.resolve('title')
    for linkTarget in _globalLinks:
        searchText = linkTarget['text']
        linkText = linkTarget['file'].split('.', 1)[0]
        if (linkText != myTitle):
            searchPattern = f'(click .*?) "({searchText}(\'?s?)?)"'
            replaceText = f'\g<1> "../{linkText}/"'
            rawText = re.sub(searchPattern, replaceText, rawText)
    unresolvedText = r'click .*? "((?!\.\./).*?)"'
    unresolvedLinks = re.findall(unresolvedText, rawText)
    if unresolvedLinks:
        for uLinkMatch in unresolvedLinks:
            msg = f'Unresolved mermaid link in {ctx.resolve("yml_file")} : {uLinkMatch}'
            warnings.warn(msg, stacklevel=7)
    return rawText
    

def sort_multi(L, *operators):
    Ls = sorted(L, key=attrgetter(*operators))
    return Ls


def stringifyKeys(dictionary):
    new_dict = dict((str(k), v) for k, v in dictionary.items())
    return new_dict


def numberFormat(value):
    try:
        formattedStr = format(int(value), ',d')
    except (TypeError, ValueError):
        formattedStr = value
    return formattedStr


def listText(text):
    return '\n    '.join(text.split('\n'))


def getTreeDirectChildren(tree):
    childless = [[node for node in children] for children in LevelOrderGroupIter(tree,
                                                                                 filter_=lambda n: not n.children)][1]
    childed = [[node for node in children] for children in LevelOrderGroupIter(tree, filter_=lambda n: n.children)][1]
    # Sort the lists
    childless.sort(key=lambda x: x.name)
    childed.sort(key=lambda x: x.name)
    return childless + childed


def humanSortIntFirst(txt):
    if isinstance(txt, int):
        number = txt
        txt = str(number)
    else:
        numMatch = re.search(r'[0-9]+', txt).group(0)
        number = int(numMatch) if numMatch is not None else -1
    return (number, txt)


def rollSort(dictionary):
    sortedList = [(key, dictionary[key]) for key in sorted(dictionary, key=humanSortIntFirst)]
    return sortedList


#--------------------------
# Sequencer
#--------------------------

def setup_jinja():
    global _env
    
    # Add in the default library
    templateLib = [_args.templates, './yaml-wiki/templates']

    env = Environment(
        loader=FileSystemLoader(templateLib),
        extensions=['jinja2.ext.do'],
        trim_blocks = True,
        lstrip_blocks = True
    )

    # Add Custom Filters
    env.filters['autoLink'] = autoLink
    env.filters['relativeLink'] = relativeLink
    env.filters['numberFormat'] = numberFormat
    env.filters['listText'] = listText
    env.filters['sort_multi'] = sort_multi
    env.filters['stringifyKeys'] = stringifyKeys
    env.filters['getTreeDirectChildren'] = getTreeDirectChildren
    env.filters['rollSort'] = rollSort

    _env = env

    
def main():
    global _globalLinks

    parse_arguments()

    setup_jinja()

    outdir = Path(_args.output)
    if outdir.exists():
        rmtree(outdir)
    
    outdir.mkdir(parents = True, exist_ok = True)
    
    #---------------------
    # Prepare the nav
    #---------------------
    
    navTree = Node('Root')
    date = datetime.today().strftime('%Y-%m-%d')
    
    timelineStruct = list()
    
    md_lib = list()
    
    
    
    for path in Path(_args.lib).glob('**/*.yml'):
    
        if '.#' in str(path):
            continue
    
        if _args.verbose > 3:
            print(path)
        
        with open(path) as y_file:
            y_data = yaml.load(y_file, Loader=yaml.FullLoader)
    
        y_data['yml_file'] = path.name
            
        outpath = Path(_args.output, path.stem).with_suffix('.md')
    
        md_lib.append({'path' : outpath, 'data' : y_data})
    
        #---------------------
        # Assemble the nav
        #---------------------
    
        rFile = Path(outpath.name)
    
        node = resolveTreeNode(navTree, f"/Root/{y_data['node']}/{y_data['title']}")
    
        node.title = y_data['title']
        node.file = str(rFile)
        node.noLink = ('control' in y_data and 'no_link' in y_data['control'])
        node.noAutoLink = ('control' in y_data and 'no_autolink' in y_data['control'])
        if 'altLinks' in y_data:
            node.altLinks = y_data['altLinks']
    
        
        # Gather timeline information for a common timeline
        if ('History' in y_data) and ('Timeline' in y_data['History']):
    
    
            # Custom sort for timeline entries
            y_data['History']['Timeline'] = sorted(
                y_data['History']['Timeline'],
                key=ageDecode)
    
    
            for event in y_data['History']['Timeline']:
                event.update({'Source' : y_data['title']})
                timelineStruct.append(event)
    
    
    #-----------------------
    # Generate the Timeline
    #-----------------------
    
    timelineTemplate = _env.get_template('Timeline.md')
    timeline = Path('./docs', 'Timeline.md')
    
    
    node = resolveTreeNode(navTree, f"/Root/General/Timeline")
    node.title = 'Timeline'
    node.file = str(timeline.name)
    node.noLink = False
    node.noAutoLink = False
    
    timelineSorted = sorted(timelineStruct, key=ageDecode)
    
    if _args.verbose > 3:
        _pp(timelineSorted)
    
    #---------------------
    # Prepare AutoLinker
    #---------------------
    
    linkedList = list()
    fileLinks = list()
    for node in PreOrderIter(navTree):
        if node.is_leaf and not node.noAutoLink:
            fileLinks.append({'title' : node.title,
                              'file' : node.file})
            linkedList.append({'text' : node.title,
                               'link' : node.title,
                               'file' : node.file})
            if hasattr(node, 'altLinks'):
                for altLink in node.altLinks:
                    linkedList.append({'text' : altLink,
                                       'link' : node.title,
                                       'file' : node.file})

    _globalLinks = sorted(linkedList, key = lambda k: len(k['text']), reverse = True)
                                   
        
    #---------------------
    # Run link templater
    #---------------------
    
    links = Path(_args.templates, 'links.md.j2')
    template = _env.get_template('links.j2')
    
    with open(links, 'w') as linkFile:
        linkFile.write(template.render(fileLinks = fileLinks))
    
    
    #---------------------
    # Write Timeline
    #---------------------
    
    with open(timeline, 'w') as timelineFile:
        timelineRender = timelineTemplate.render(timeline = timelineSorted, date=date)
        timelineFile.write(timelineRender)
        
        
    #---------------------
    # Run Templater
    #---------------------
    for entry in md_lib:
    
        outpath = entry['path']
        
        y_data = entry['data']
    
        template = _env.get_template(y_data['template'])
    
        with open(outpath, 'w') as outfile:
            outfile.write(template.render(y_data, date=date))
                
    #---------------------
    # Write the Cat Pages
    #---------------------
    
    template = _env.get_template('Category.md')
    for category in navTree.children:
        # Make sure it really is a category
        if category.children:
            page = Path(outdir, category.name).with_suffix('.md')
            category.file = page.name
            with open(page, 'w') as pageFile:
                pageFile.write(template.render(navTree = category,
                                               date = date))
    
    #---------------------
    # Write the config
    #---------------------
    
    template = _env.get_template('mkdocs.yml.j2')
    config = Path('mkdocs.yml')
    with open(config, 'w') as configFile:
        configFile.write(template.render(navTree = navTree))
    
    
        
    #---------------------
    # Write the Main Page
    #---------------------
    
    template = _env.get_template('index.md')
    index = Path(outdir, 'index.md')
    
    with open(index, 'w') as indexFile:
        indexFile.write(template.render(navTree = navTree,
                                        date = date))
    
    
    libpath = Path('..', _args.lib)
    
    symlink(Path('../yaml-wiki/lib/stylesheets'), outdir.joinpath('stylesheets_lib'), target_is_directory=True)
    symlink(Path('../yaml-wiki/lib/js'), outdir.joinpath('js_lib'), target_is_directory=True)
    
    if _args.js:
        symlink(libpath.joinpath(_args.js), outdir.joinpath(_args.js), target_is_directory=True)
    
    if _args.stylesheets:
        symlink(libpath.joinpath(_args.stylesheets), outdir.joinpath(_args.stylesheets), target_is_directory=True)
    
    if _args.img:
        symlink(libpath.joinpath(_args.img), outdir.joinpath(_args.img), target_is_directory=True)
        
    

if __name__ == "__main__":
    main()
